#!/usr/bin/env bash

set -e
set -o pipefail

main() {
  case "$1" in
    load)
      shift
      ensure_op_logged_in_or_exit
      load_command "$@"
      ;;
    *)
      print_usage_and_exit
      ;;
  esac
}

ensure_op_logged_in_or_exit() {
  if ! easy-op status > /dev/null; then
    echo "!! You must be signed-in to 1 Password !!"
    exit 1
  fi
}

load_command() {
  # I can't figure out what good defaults would look like. There are so many
  # ways to slice and dice things in 1 Password. I could see a single note
  # called "keychain" whith many private key fields hanging off of it. I am
  # preferring NOT to use the "notesPlain" value because I prefer to use that
  # for Item metadata and other misc information.
  #
  # 1 Passwords strength is its great flexibility, but it also imposes a lot
  # of decision making to be done.
  #
  # Another consequence of using fields is that the key needs to be base64
  # encoded because fields cannot be multi-line.
  #
  # The string used to fetch the field also doesn't need to be the same as the
  # string that is displayed through the 1 Password GUI. This could make
  # discoverability quite hard to other tools don't keep these values the same.
  #
  # See: https://github.com/scottmuc/infrastructure/blob/365fe76b71c520c947cd482ef4ed11ac132f8921/homedirs/osx/bin/create-repave-secrets#L61-L66
  local note_name="keychain"
  local field_name="base64 encoded ssh private key"
  local password_field_name=""
  local timeout="1"

  while getopts ":n:f:p:t:" opt; do
    case $opt in
      n) note_name="$OPTARG"
      ;;
      f) field_name="$OPTARG"
      ;;
      p) password_field_name="$OPTARG"
      ;;
      t) timeout="$OPTARG"
      ;;
      \?) print_usage_and_exit
      ;;
    esac
  done

  load "${note_name}" "${field_name}" "${password_field_name}" "${timeout}"
}

load() {
  # Assuming default values have been passed in
  local note_name="$1"
  local field_name="$2"
  local password_field_name="$3"
  local timeout="$4"

  timeout_in_seconds="$(echo "${timeout}*3600" | bc)"

  local base64_key="$(easy-op show -n "${note_name}" -f "${field_name}")"
  local decoded_key="$(echo "${base64_key}" | base64 -D)"

  # The presence of DISPLAY will enable our setting of SSH_ASKPASS
  # to be executed. If I could do this as an argument to `env` I would.
  # I just don't know how ;-)
  if [[ -n "${password_field_name}" ]]; then
    export DISPLAY=""
  fi

  echo "Adding \"${note_name}\".\"${field_name}\" to your ssh-agent for ${timeout} hour(s)"
  env \
    SSH_OP_ASKPASS_NOTE="${note_name}" \
    SSH_OP_ASKPASS_FIELD="${password_field_name}" \
    SSH_ASKPASS="ssh_op_askpass" \
    ssh-add -t "${timeout_in_seconds}" - <<< "$(echo -e "${decoded_key}")"
}

print_usage_and_exit() {
  cat <<USAGE
usage: $0 <command> <args>

Grabs ssh keys from 1 Password and stores them in your ssh-agent. Currently
this only works with Secure Notes because of the way 1 Password structures
its data internally.

Commands:
 - load
     adds a secure note into your ssh-agent

     -n      specify the name of the item (default: "keychain")

     -f      specify the field of the key; needs to be base64 encoded (default: "base64 encoded ssh private key")

     -p      specify the field (assuming the same note specified with -n) containing the key's passphrase (optional)

     -t      specify a timeout in hrs (default: 1)

Examples:

ssh_op_agent load -n test -f "base64 encoded ssh private key" -p "ssh key passphrase"
USAGE

  exit 1
}

main "$@"
